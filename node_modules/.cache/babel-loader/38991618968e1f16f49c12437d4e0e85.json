{"ast":null,"code":"import { spacing } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(_ref => {\n      let {\n        stickyNode\n      } = _ref;\n      return nodeToRemove === stickyNode;\n    });\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n  setContainer(el) {\n    this.container = el;\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacing['space-5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(_ref2 => {\n      let {\n        stickyNode\n      } = _ref2;\n      return nodeToRemove === stickyNode;\n    });\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n      count++;\n    }\n    return offset;\n  }\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(_ref3 => {\n      let {\n        stickyNode\n      } = _ref3;\n      return node === stickyNode;\n    });\n    return nodeFound >= 0;\n  }\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n}\nfunction isDocument(node) {\n  return node === document;\n}\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\nexport { StickyManager };","map":{"version":3,"names":["spacing","debounce","scrollable","dataPolarisTopBar","stackedContent","getRectForNode","SIXTY_FPS","StickyManager","constructor","container","stickyItems","stuckItems","topBarOffset","handleResize","manageStickyItems","leading","trailing","maxWait","handleScroll","setContainer","registerStickyItem","stickyItem","push","unregisterStickyItem","nodeToRemove","nodeIndex","findIndex","stickyNode","splice","el","isDocument","setTopBarOffset","addEventListener","window","removeScrollListener","removeEventListener","length","scrollTop","scrollTopFor","containerTop","top","forEach","handlePositioning","sticky","left","width","evaluateStickyItem","updateStuckItems","placeHolderNode","boundingElement","offset","disableWhenStacked","matches","stickyOffset","getOffset","parseInt","scrollPosition","placeHolderNodeCurrentTop","getBoundingClientRect","_stickyNode$firstElem","stickyItemHeight","height","firstElementChild","stickyItemBottomPosition","bottom","item","isNodeStuck","addStuckItem","removeStuckItem","node","count","stuckNodesLength","nodeRect","stuckNode","stuckNodeRect","horizontallyOverlaps","nodeFound","topbarElement","querySelector","selector","clientHeight","document","body","documentElement","rect1","rect2","rect1Left","rect1Right","rect2Left","rect2Right"],"sources":["/home/cedcoss/Desktop/redux-xhat-app/node_modules/@shopify/polaris/build/esm/utilities/sticky-manager/sticky-manager.js"],"sourcesContent":["import { spacing } from '@shopify/polaris-tokens';\nimport { debounce } from '../debounce.js';\nimport { scrollable, dataPolarisTopBar } from '../../components/shared.js';\nimport { stackedContent } from '../breakpoints.js';\nimport { getRectForNode } from '../geometry.js';\n\nconst SIXTY_FPS = 1000 / 60;\nclass StickyManager {\n  constructor(container) {\n    this.stickyItems = [];\n    this.stuckItems = [];\n    this.container = null;\n    this.topBarOffset = 0;\n    this.handleResize = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n    this.handleScroll = debounce(() => {\n      this.manageStickyItems();\n    }, SIXTY_FPS, {\n      leading: true,\n      trailing: true,\n      maxWait: SIXTY_FPS\n    });\n\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n\n  registerStickyItem(stickyItem) {\n    this.stickyItems.push(stickyItem);\n  }\n\n  unregisterStickyItem(nodeToRemove) {\n    const nodeIndex = this.stickyItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stickyItems.splice(nodeIndex, 1);\n  }\n\n  setContainer(el) {\n    this.container = el;\n\n    if (isDocument(el)) {\n      this.setTopBarOffset(el);\n    }\n\n    this.container.addEventListener('scroll', this.handleScroll);\n    window.addEventListener('resize', this.handleResize);\n    this.manageStickyItems();\n  }\n\n  removeScrollListener() {\n    if (this.container) {\n      this.container.removeEventListener('scroll', this.handleScroll);\n      window.removeEventListener('resize', this.handleResize);\n    }\n  }\n\n  manageStickyItems() {\n    if (this.stickyItems.length <= 0) {\n      return;\n    }\n\n    const scrollTop = this.container ? scrollTopFor(this.container) : 0;\n    const containerTop = getRectForNode(this.container).top + this.topBarOffset;\n    this.stickyItems.forEach(stickyItem => {\n      const {\n        handlePositioning\n      } = stickyItem;\n      const {\n        sticky,\n        top,\n        left,\n        width\n      } = this.evaluateStickyItem(stickyItem, scrollTop, containerTop);\n      this.updateStuckItems(stickyItem, sticky);\n      handlePositioning(sticky, top, left, width);\n    });\n  }\n\n  evaluateStickyItem(stickyItem, scrollTop, containerTop) {\n    const {\n      stickyNode,\n      placeHolderNode,\n      boundingElement,\n      offset,\n      disableWhenStacked\n    } = stickyItem;\n\n    if (disableWhenStacked && stackedContent().matches) {\n      return {\n        sticky: false,\n        top: 0,\n        left: 0,\n        width: 'auto'\n      };\n    }\n\n    const stickyOffset = offset ? this.getOffset(stickyNode) + parseInt(spacing['space-5'], 10) : this.getOffset(stickyNode);\n    const scrollPosition = scrollTop + stickyOffset;\n    const placeHolderNodeCurrentTop = placeHolderNode.getBoundingClientRect().top - containerTop + scrollTop;\n    const top = containerTop + stickyOffset;\n    const width = placeHolderNode.getBoundingClientRect().width;\n    const left = placeHolderNode.getBoundingClientRect().left;\n    let sticky;\n\n    if (boundingElement == null) {\n      sticky = scrollPosition >= placeHolderNodeCurrentTop;\n    } else {\n      var _stickyNode$firstElem;\n\n      const stickyItemHeight = stickyNode.getBoundingClientRect().height || ((_stickyNode$firstElem = stickyNode.firstElementChild) === null || _stickyNode$firstElem === void 0 ? void 0 : _stickyNode$firstElem.getBoundingClientRect().height) || 0;\n      const stickyItemBottomPosition = boundingElement.getBoundingClientRect().bottom - stickyItemHeight + scrollTop - containerTop;\n      sticky = scrollPosition >= placeHolderNodeCurrentTop && scrollPosition < stickyItemBottomPosition;\n    }\n\n    return {\n      sticky,\n      top,\n      left,\n      width\n    };\n  }\n\n  updateStuckItems(item, sticky) {\n    const {\n      stickyNode\n    } = item;\n\n    if (sticky && !this.isNodeStuck(stickyNode)) {\n      this.addStuckItem(item);\n    } else if (!sticky && this.isNodeStuck(stickyNode)) {\n      this.removeStuckItem(item);\n    }\n  }\n\n  addStuckItem(stickyItem) {\n    this.stuckItems.push(stickyItem);\n  }\n\n  removeStuckItem(stickyItem) {\n    const {\n      stickyNode: nodeToRemove\n    } = stickyItem;\n    const nodeIndex = this.stuckItems.findIndex(({\n      stickyNode\n    }) => nodeToRemove === stickyNode);\n    this.stuckItems.splice(nodeIndex, 1);\n  }\n\n  getOffset(node) {\n    if (this.stuckItems.length === 0) {\n      return 0;\n    }\n\n    let offset = 0;\n    let count = 0;\n    const stuckNodesLength = this.stuckItems.length;\n    const nodeRect = getRectForNode(node);\n\n    while (count < stuckNodesLength) {\n      const stuckNode = this.stuckItems[count].stickyNode;\n\n      if (stuckNode !== node) {\n        const stuckNodeRect = getRectForNode(stuckNode);\n\n        if (!horizontallyOverlaps(nodeRect, stuckNodeRect)) {\n          offset += getRectForNode(stuckNode).height;\n        }\n      } else {\n        break;\n      }\n\n      count++;\n    }\n\n    return offset;\n  }\n\n  isNodeStuck(node) {\n    const nodeFound = this.stuckItems.findIndex(({\n      stickyNode\n    }) => node === stickyNode);\n    return nodeFound >= 0;\n  }\n\n  setTopBarOffset(container) {\n    const topbarElement = container.querySelector(`:not(${scrollable.selector}) ${dataPolarisTopBar.selector}`);\n    this.topBarOffset = topbarElement ? topbarElement.clientHeight : 0;\n  }\n\n}\n\nfunction isDocument(node) {\n  return node === document;\n}\n\nfunction scrollTopFor(container) {\n  return isDocument(container) ? document.body.scrollTop || document.documentElement.scrollTop : container.scrollTop;\n}\n\nfunction horizontallyOverlaps(rect1, rect2) {\n  const rect1Left = rect1.left;\n  const rect1Right = rect1.left + rect1.width;\n  const rect2Left = rect2.left;\n  const rect2Right = rect2.left + rect2.width;\n  return rect2Right < rect1Left || rect1Right < rect2Left;\n}\n\nexport { StickyManager };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}