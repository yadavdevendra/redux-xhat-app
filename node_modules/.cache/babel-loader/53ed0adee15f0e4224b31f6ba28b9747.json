{"ast":null,"code":"// Unfortunately, this is how we have to type this at the moment.\n// There is currently a proposal to support variadic kinds.\n// https://github.com/Microsoft/TypeScript/issues/5453\nfunction merge() {\n  let final = {};\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n  for (const obj of objs) {\n    final = mergeRecursively(final, obj);\n  }\n  return final;\n}\nfunction mergeRecursively(inputObjA, objB) {\n  const objA = Array.isArray(inputObjA) ? [...inputObjA] : {\n    ...inputObjA\n  };\n  for (const key in objB) {\n    if (!Object.prototype.hasOwnProperty.call(objB, key)) {\n      continue;\n    } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {\n      objA[key] = mergeRecursively(objA[key], objB[key]);\n    } else {\n      objA[key] = objB[key];\n    }\n  }\n  return objA;\n}\nfunction isMergeableValue(value) {\n  return value !== null && typeof value === 'object';\n}\nexport { merge };","map":{"version":3,"names":["merge","final","objs","obj","mergeRecursively","inputObjA","objB","objA","Array","isArray","key","Object","prototype","hasOwnProperty","call","isMergeableValue","value"],"sources":["/home/cedcoss/Desktop/redux-xhat-app/node_modules/@shopify/polaris/build/esm/utilities/merge.js"],"sourcesContent":["// Unfortunately, this is how we have to type this at the moment.\n// There is currently a proposal to support variadic kinds.\n// https://github.com/Microsoft/TypeScript/issues/5453\nfunction merge(...objs) {\n  let final = {};\n\n  for (const obj of objs) {\n    final = mergeRecursively(final, obj);\n  }\n\n  return final;\n}\n\nfunction mergeRecursively(inputObjA, objB) {\n  const objA = Array.isArray(inputObjA) ? [...inputObjA] : { ...inputObjA\n  };\n\n  for (const key in objB) {\n    if (!Object.prototype.hasOwnProperty.call(objB, key)) {\n      continue;\n    } else if (isMergeableValue(objB[key]) && isMergeableValue(objA[key])) {\n      objA[key] = mergeRecursively(objA[key], objB[key]);\n    } else {\n      objA[key] = objB[key];\n    }\n  }\n\n  return objA;\n}\n\nfunction isMergeableValue(value) {\n  return value !== null && typeof value === 'object';\n}\n\nexport { merge };\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,KAAK,GAAU;EACtB,IAAIC,KAAK,GAAG,CAAC,CAAC;EAAC,kCADCC,IAAI;IAAJA,IAAI;EAAA;EAGpB,KAAK,MAAMC,GAAG,IAAID,IAAI,EAAE;IACtBD,KAAK,GAAGG,gBAAgB,CAACH,KAAK,EAAEE,GAAG,CAAC;EACtC;EAEA,OAAOF,KAAK;AACd;AAEA,SAASG,gBAAgB,CAACC,SAAS,EAAEC,IAAI,EAAE;EACzC,MAAMC,IAAI,GAAGC,KAAK,CAACC,OAAO,CAACJ,SAAS,CAAC,GAAG,CAAC,GAAGA,SAAS,CAAC,GAAG;IAAE,GAAGA;EAC9D,CAAC;EAED,KAAK,MAAMK,GAAG,IAAIJ,IAAI,EAAE;IACtB,IAAI,CAACK,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACR,IAAI,EAAEI,GAAG,CAAC,EAAE;MACpD;IACF,CAAC,MAAM,IAAIK,gBAAgB,CAACT,IAAI,CAACI,GAAG,CAAC,CAAC,IAAIK,gBAAgB,CAACR,IAAI,CAACG,GAAG,CAAC,CAAC,EAAE;MACrEH,IAAI,CAACG,GAAG,CAAC,GAAGN,gBAAgB,CAACG,IAAI,CAACG,GAAG,CAAC,EAAEJ,IAAI,CAACI,GAAG,CAAC,CAAC;IACpD,CAAC,MAAM;MACLH,IAAI,CAACG,GAAG,CAAC,GAAGJ,IAAI,CAACI,GAAG,CAAC;IACvB;EACF;EAEA,OAAOH,IAAI;AACb;AAEA,SAASQ,gBAAgB,CAACC,KAAK,EAAE;EAC/B,OAAOA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ;AACpD;AAEA,SAAShB,KAAK"},"metadata":{},"sourceType":"module"}