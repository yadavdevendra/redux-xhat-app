{"ast":null,"code":"function debounce(func, waitArg, options) {\n  let lastArgs;\n  let lastThis;\n  let maxWait;\n  let result;\n  let timerId;\n  let lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n\n  const useRAF = !waitArg && waitArg !== 0;\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  const wait = waitArg || 0;\n  if (typeof options === 'object') {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : undefined;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n    lastArgs = undefined;\n    lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      cancelAnimationFrame(timerId);\n      return requestAnimationFrame(pendingFunc);\n    }\n    return setTimeout(pendingFunc, wait);\n  }\n  function cancelTimer(id) {\n    if (useRAF) {\n      return cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = startTimer(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n    return maxing && maxWait ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && maxWait && timeSinceLastInvoke >= maxWait;\n  }\n  function timerExpired() {\n    const time = Date.now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    } // eslint-disable-next-line no-multi-assign\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0; // eslint-disable-next-line no-multi-assign\n\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n  function pending() {\n    return timerId !== undefined;\n  }\n  function debounced() {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    lastArgs = args; // eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias\n\n    lastThis = this;\n    lastCallTime = time;\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\nexport { debounce };","map":{"version":3,"names":["debounce","func","waitArg","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","TypeError","wait","Boolean","Math","max","Number","undefined","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","cancelAnimationFrame","requestAnimationFrame","setTimeout","cancelTimer","id","clearTimeout","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","timeWaiting","min","shouldInvoke","Date","now","trailingEdge","cancel","flush","pending","debounced","isInvoking"],"sources":["/home/cedcoss/Desktop/redux-xhat-app/node_modules/@shopify/polaris/build/esm/utilities/debounce.js"],"sourcesContent":["function debounce(func, waitArg, options) {\n  let lastArgs;\n  let lastThis;\n  let maxWait;\n  let result;\n  let timerId;\n  let lastCallTime;\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true; // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n\n  const useRAF = !waitArg && waitArg !== 0;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  const wait = waitArg || 0;\n\n  if (typeof options === 'object') {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : undefined;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n    lastArgs = undefined;\n    lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      cancelAnimationFrame(timerId);\n      return requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return cancelAnimationFrame(id);\n    }\n\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time; // Start the timer for the trailing edge.\n\n    timerId = startTimer(timerExpired, wait); // Invoke the leading edge.\n\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n    return maxing && maxWait ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n\n    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && maxWait && timeSinceLastInvoke >= maxWait;\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    } // Restart the timer.\n\n\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    } // eslint-disable-next-line no-multi-assign\n\n\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n\n    lastInvokeTime = 0; // eslint-disable-next-line no-multi-assign\n\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n    lastArgs = args; // eslint-disable-next-line consistent-this, @typescript-eslint/no-this-alias\n\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\n\nexport { debounce };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}